#!/usr/bin/env runhaskell
import Data.Maybe
import qualified Data.Map as Map
import Data.Time.Calendar.WeekDate (toWeekDate)
import Data.Time.LocalTime
  (ZonedTime, TimeOfDay, getZonedTime, localDay, localTimeOfDay,
   zonedTimeToLocalTime, todHour)

data Day = Monday 
         | Tuesday
         | Wednesday
         | Thursday
         | Friday
         | Saturday
         | Sunday
         deriving (Eq, Ord, Show, Read, Enum)

type Location = String
type DayLocations = Map.Map Day Location

locations :: DayLocations
locations = Map.fromList
    [ (Monday,    "Svargrond")
    , (Tuesday,   "Liberty Bay")
    , (Wednesday, "Port Hope")
    , (Thursday,  "Ankrahmun")
    , (Friday,    "Darashia")
    , (Saturday,  "Edron")
    , (Sunday,    "Carlin")
    ]

-- toWeekDate numbers the days 1 for Monday to 7 for Sunday.
weekDateToDayOfWeek :: (Integer, Int, Int) -> Day
weekDateToDayOfWeek (_, _, d) = toEnum (d - 1)

timeOfDayDayOfWeek :: ZonedTime -> (TimeOfDay, Day)
timeOfDayDayOfWeek zt = let lt = zonedTimeToLocalTime zt
                            dow = (weekDateToDayOfWeek . toWeekDate . localDay) lt
                            tod = localTimeOfDay lt
                        in (tod, dow)

virtuallyPrevDay :: TimeOfDay -> Day -> Day
virtuallyPrevDay tod day
    | todHour tod < 9 = if day == Monday then Sunday else pred day
    | otherwise       = day

lookupLocation :: Day -> DayLocations -> Location
lookupLocation d xs = let maybeDay = Map.lookup d xs
                      in fromMaybe "Not found" maybeDay

main = do
    zt <- getZonedTime
    let (tod, dow) = timeOfDayDayOfWeek zt
    let virtualDay = virtuallyPrevDay tod dow
    print $ lookupLocation virtualDay locations
